---
share: "true"
created: 2026年-01月-08日 18:15
date modified: 2026年-01月-08日 22:21
---

# 基础题

###  在业务逻辑代码中实现导航跳转的方式称为 <font color="#00b0f0">编程式导航</font>

###  vue-router默认的路由模式为 <font color="#00b0f0">hash模式</font>

### 每个路由导航钩子函数接收 to 、from 和 next 三个参数。

### 编程式导航中通过router.push()传递参数的形式主要分为 query 和 params 两种。

### 使用axios发送请求时,用于处理请求失败的回调函数的方法是 catch()

### 使用axios发送请求时,用于处理请求成功的回调函数的方法是 then()

### 通过路由实现组件之间的切换需要使用 `<router-link></router-link>` 组件

###  Vuex 实例对象中组件状态通过 mutations 改变

### 关键解析：

在 Vuex 中，**组件不能直接修改 state**（这是 Vuex 的重要原则，目的是保证状态变更的可追踪性）。正确的做法是通过 **`mutations`** 来修改状态，因为：

- `mutations` 是唯一允许修改 state 的地方，且必须是**同步函数**（方便调试和时间旅行）。
- 组件通过 `this.$store.commit('mutationName', payload)` 来触发 mutations。

---

### 拓展思考：

如果需要处理**异步操作**（如 API 请求），应该先通过 **`actions`** 完成异步逻辑，再在 actions 中提交 mutations 修改状态。

###  Vue.js框架的单文件组件是以 .vue 后缀命名的文件格式

### 命名路由是通过 name 属性为路由规则定义路由名称。

###  路由中使用`<router-view></router-view>`组件可以显示与URL对应的组件内容。

### Axios在浏览器中使用 XMLHttpRequest 对象发送请求。

###  在路由匹配规则中，通过 children 属性可以定义子路由匹配规则。

### 使用命名路由，只需要使用包含 name 属性的对象即可。

### 关键解析：

在 Vue Router 中，**命名路由**允许我们通过路由的 `name` 属性来标识一个路由规则，从而在跳转时更直观、更语义化。使用命名路由时，我们不需要直接写路径字符串，而是传递一个包含 **`name` 属性的对象**给 `router.push()` 或 `<router-link>` 的 `:to` 属性。

---

### vue-router的路由模式主要分为：hash模式 和 history模式两种模式。

### 关键解析：

在 Vue Router 中，当组件模板包含 **嵌套的 `<router-view>`**（即子路由出口）时，需要通过路由配置中的 **`children` 参数**来定义子路由规则。`children` 是一个数组，用于存放当前路由的子路由配置，这样当访问子路由路径时，对应的组件就会渲染到父组件的嵌套 `<router-view>` 中

---

###  除了使用`<router-link>`创建`<a>`标签可以定义导航链接之外， 还可以使用 router的 push() 方法实现导航的功能。

### Vue的重定向功能通过routes配置 redirect和 path 来完成。

### hash 模式路由，地址栏 URL 中会自带 # 符号

### 在pinia状态管理中，挂载**_pinia-plugin-persist_**插件后，在模块中实现持久化存储。

### 获取参数的语法有误。在 Vue 组件实例中，访问当前路由对象需要加上 `$` 符号。正确的写法应该是 `this.$route.query.参数名`，而不是 `this.route...`。

| **特性**     | **Query 传参**               | **Params 传参**                                         |
| ------------ | ---------------------------- | ------------------------------------------------------- |
| **URL 表现** | 显示在 URL 中 (`/path?id=1`) | 若配置了动态路由则显示 (`/path/1`)，否则可能不显示      |
| **引入方式** | 配合 `path` 或 `name` 使用   | 必须配合 `name` 使用 (若使用 `path`，`params` 会被忽略) |
| **刷新页面** | **参数不会丢失**             | 若未在路由配置中定义占位符，**刷新后参数会丢失**        |
| **获取方式** | `this.$route.query.xx`       | `this.$route.params.xx`                                 |

Hash 模式监听 URL 哈希值（`#` 后面的部分）变化的事件名称是 **`hashchange`**，而不是 `onchange`。

- `onchange` 事件通常用于表单元素（如 `<input>`、`<select>`），当用户改变输入值并失去焦点时触发。
- 当 URL 中的 hash 发生变化时，浏览器会触发 window 对象的 `hashchange` 事件，Vue Router 正是利用这个事件来感知路由变化并进行组件切换的。

- **“mutations 是 Vuex 中唯一修改 state 的方式”** —— 这半句在理论上是正确的（Vuex 设计原则要求所有状态变更必须通过 mutation，以便追踪）。
- **“支持异步操作”** —— **这是严重错误的**。在 Vuex 中，**Mutations 必须是同步函数**。

**Vuex** 是一个专为 Vue.js 应用程序开发的状态管理模式。它的核心概念包括以下几个部分，而 `setters` 并不在其列：

1. **State（状态）：** 驱动应用的数据源，单一状态树。
2. **Getters（获取器）：** 可以理解为 store 的计算属性，用于从 store 中的 state 中派生出一些状态（对应选项 D）。
3. **Mutations（变更）：** 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。它们必须是同步函数（对应选项 B）。
4. **Actions（动作）：** 类似于 mutation，不同在于 Action 提交的是 mutation，而不是直接变更状态，并且可以包含任意异步操作（对应选项 A）。
5. **Modules（模块）：** 允许将 store 分割成模块。

**Axios** 是一个基于 Promise 的 HTTP 库，可以用在浏览器和 Node.js 中。它的主要特性（Features）官方文档中列明如下：

1. **从浏览器中创建 XMLHttpRequests**。
2. **从 node.js 创建 http 请求**。
3. **支持 Promise API**（这是关键点，选项 A 的表述不准确）。
4. **拦截请求和响应**（对应选项 D）。
5. **转换请求数据和响应数据**（对应选项 B）。
6. **取消请求**。
7. **自动转换 JSON 数据**。
8. **客户端支持防御 XSRF/CSRF**（对应选项 C）。

**Vue Router 常用的编程式导航方法**

- `router.push(...)`：跳转并保留历史记录。
- `router.replace(...)`：跳转但不保留历史记录（替换当前页）。
- `router.go(n)`：在历史记录中向前或后退 n 步（例如 `go(-1)` 相当于后退）。
- `router.back()`：后退。
- `router.forward()`：前进。

前端路由（Frontend Routing）最大的特点是**“无刷新”**（No Refresh）。

- 当 URL 发生变化时，前端路由（如 Vue Router）会通过 JavaScript 拦截这个变化，并动态更新页面中的 DOM 节点（通常是替换组件），**而不是**触发浏览器的页面整体刷新（Reload）。
- 选项中提到的“页面进行实时刷新”通常指的是传统的页面跳转（整个页面重新加载），这恰恰是后端路由的行为，而不是前端路由的特征。

Pinia 的一个核心设计理念就是“去模块化”**（No Modules）**，或者说是**扁平化**设计。

- **区别于 Vuex：** 在 Vuex 中，我们需要在一个单一的 store 中通过 `modules` 属性来嵌套配置各个模块（nested structure），这往往导致代码结构复杂、类型推导困难。
- **Pinia 的做法：** Pinia **废弃了** `modules` 这种嵌套配置方式。在 Pinia 中，你通过 `defineStore` 创建的每一个 store 都是独立的。如果你需要“模块化”，只需要创建多个独立的 store 文件，然后在需要的地方分别引入即可（通过 ES6 模块导入导出）。这种扁平化的架构让代码更加简洁，且更容易进行代码分割和类型推断

在 Vuex 的设计原则中，**Vue 组件不应该（也不推荐）直接修改 `state` 的状态**。

**在 Vue Router 4 (Vue 3) 中：**

- `next` 参数是**可选**的。
- 如果不写 `next` 参数（即函数签名为 `(to, from) => { ... }`），路由守卫会根据**返回值**来决定行为。
- 如果函数没有返回值（返回 `undefined`）或者返回 `true`，导航默认是**被允许**的。
- 因此，"省略 next 参数则不允许访问" 的说法是完全错误的。实际上，省略它是现代 Vue Router 推荐的写法（除非你需要进行复杂的异步流程控制）。

在 Vue Router 中，如果提供了 `path` 属性，`params` 会被**忽略**。

- **规则：** `path` 不能和 `params` 一起使用。
- **后果：** 代码 `this.$router.push({ path: 'home', params: { id: '2' }})` 执行时，路由器会直接跳转到 `'home'` 路径，而忽略掉 `{ id: '2' }` 这个参数。目标页面将无法获取到这个 id。

### Vue是一套构建**_用户界面_**的渐进式框架。

### 每个Vue 3.x 应用都是通过**_createApp_**函数创建一个新的应用实例。

### Vue实例对象通过**_vue构造器_**来创建。

### Vue初始数据在实例对象的**data函数**中进行定义。

### MVVM 主要包含3个部分，分别是**_Model_**、**View**和**_ViewModel_**。

### 下列选项中，用于渲染DOM元素的文本内容的指令是（ v-text）

### 在动态组件中，使用component元素结合_:is_属性实现组件切换。

### 在使用选项式API时，可以通过_methods_选项来定义方法。

### 在使用provide()函数注入数据时，如果提供的数据不希望被注入方的组件更改，可以使用_readonly_来包装提供的值。

### 组合式API相比于选项式API，是将组件中的数据、方法、计算属性、侦听器等代码全部组合在一起，写在_setup_函数中。

### CSS过渡效果中，_v-leave-to_类进入动画的结束状态。

### 实现列表过渡需要使用___v-for___指令和_transition-group_组件。

### Vue提供了内置的过渡封装组件_transition_，该组件用于包含要实现过渡效果的DOM元素。

### Element Plus中常用的button组件使用_`<el-button></el-button>`_标签定义。

### 在CSS过渡中需要_transition_属性实现过渡效果。

### 使用_`<keep-alive></keep-alive>`_包裹动态组件时，会缓存不活动的组件实例而不是销毁它们。

###  在CSS动画中需要使用_animation_属性实现动画的效果。

### 具名插槽是指可以为每个`<slot>`元素指定不同的_name_。



# 简答题

### 阐述一下什么是MVVM模式？

MVVM全称是Model-View-ViewModel
（1）Model代表整个Web项目所需要的数据模型， Model含有大量信息，但它并不具有任何行为逻辑，它只是数据，因而它不会影响浏览器如何展示数据。
（2）View是具有主动性的，因为它包括了一些数据绑定、事件和行为，这些都会直接影响Model和ViewModel的。它不但负责保持View自身的展示，而且还会将自身的变化同步到ViewModel中。
（3）ViewModel：MVVM中的VM主要负责用一定的业务逻辑对数据进行改变或转换，也负责将Model的变化反应到View上，而当View自身有变化时也会同步Model进行改变。

###  vue为事件绑定指令提供了哪些修饰符？其作用分别是什么？
（1）.prevent：阻止默认行为（如阻止超链接的跳转、表单的提交）
（2）.stop：阻止事件冒泡
（3）.capture：以捕获模式触发当前的事件处理函数
（4）.once：绑定的事件只触发1次
（5）.self：只有在event.target是当前元素自身时触发事件处理函数

### 简单描述一下vue.js的特点有哪些？
（1）轻量高效：Vue.js压缩后只有几十KB，它通过简洁的API提供高效的数据绑定和灵活的组件系统
（2）组件化开发：通过Vue.js的模块封装，它可以将一个Web开发中设计的各种模块进行拆分，变成单独的组件，然后通过数据绑定，调用对应的组件，同时传入参数，完成对整个项目的开发
（3）前端路由：Vue-Router是Vue.js官方的路由管理器，路由用于设定访问路径，根据路径的不同，驱动不同的组件，实现单页面的展示
（4）状态管理：Vuex是一个专为Vue.js应用程序开发的状态管理模式，它负责把需要共享的变量或数据全部存储在一个对象里面，供其他组件使用，其采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化
（5）虚拟DOM：虚拟DOM就是一种可以预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化的技术，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫作虚拟DOM。

### 阐述一下计算属性computed和监听watch的区别分别有哪些？
（1）缓存机制：计算属性（computed）具有缓存机制，只有当它依赖的数据发生改变时，才会重新计算属性值。而监听（watch）不具备缓存机制，每次监听的数据发生变化时都会执行对应的回调。
（2）异步操作：计算属性（computed）不支持异步操作，当计算属性内有异步操作时无效，无法监听数据的变化。而监听（watch）则支持异步操作。
（3）数据依赖关系：计算属性（computed）适用于一个属性受多个属性影响的情况，例如购物车多选按钮。而监听（watch）适用于一条数据影响多条数据的情况。
（4）函数返回值：计算属性（computed）必须调用return语句，函数的返回值就是属性的属性值。而在监听（watch）中，无需调用return语句。
（5）执行效率：由于计算属性（computed）具有缓存机制，因此在处理复杂计算时，其执行效率可能高于监听（watch）。然而，在处理简单计算或仅需观察数据变化时，两者的执行效率可能相近。

### 阐述一下计算属性computed的特点有哪些？与方法methods的区别有哪些？
（1）计算属性computed的特点：
	①当计算属性依赖的数据发生了变化，就会立即进行计算，并对计算结果进行自动更新。
	②计算属性的求值结果会被缓存起来，方便下次直接使用。
	③计算属性适用于执行更加复杂的表达式，这些表达式往往太长或需要频繁地重复使用。
	④计算属性基本上就像是data对象的一个扩展和增强版本。
（2）计算属性computed与方法methods的区别：计算属性computed会立即返回缓存的计算结果，而不会执行函数，只有当计算属性的依赖发生变化时，代码才会被执行；而methods会每访问一次就执行一次函数。

### 阐述一下Vue.js中内置指令有哪些？其作用是什么？
（1）v-model：双向数据绑定;
（2）v-on：监听事件;
（3）v-bind：单向数据绑定;
（4）v-text：插入文本内容;
（5）v-html：插入包含HTML的内容
（6）v-for：列表渲染
（7）v-if：条件渲染
（8）v-show：显示隐藏

### 使用vue.js的优势有哪些？
（1）轻量级：Vue简单、直接，所以Vue使用起来更加友好
（2）数据绑定：数据驱动视图，视图也可以驱动数据
（3）指令：指令绑定在元素上时，指令会给绑定的元素添加一些特殊的行为
（4）插件：插件用于对Vue框架功能进行扩展

### vue中的指令按照不同的用途可以分为几大类？
（1）内容渲染指令
（2）属性绑定指令
（3）事件绑定指令
（4）双向绑定指令
（5）条件渲染指令
（6）列表渲染指令

### 阐述一下vue的配置对象有哪些？
（1）data选项：Vue实例数据对象;
（2）methods选项：定义Vue实例中的方法;
（3）components选项：定义子组件;
（4）computed选项：计算属性;
（5）watch选项：监听数据变化
（6）filters选项：过滤器

### 阐述一下v-if与v-show的区别。
（1）实现原理不同：
	①v-if指令会动态地创建或移除DOM元素，从而控制元素在页面上的显示与隐藏；
	②v-show 指令会动态为元素添加或移除 style="display: none;" 样式，从而控制元素的显示与隐藏；
（2）性能消耗不同：
	①v-if有更高的切换开销，而v-show有更高的初始渲染开销
	②如果需要非常频繁地切换，则使用v-show较好
	③如果在运行时条件很少改变，则使用v-if较好

### vue为数据双向绑定指令提供了哪些修饰符？其作用分别是什么？
（1）.number：自动将用户的输入值转为数值类型
（2）.trim：自动过滤用户输入的首尾空白字符
（3）.lazy：在input输入框输入数据时，v-model绑定的值不会发发生变化，但是当输入框失去焦点时，v-model绑定的值才会发生变化，即在“change”时而非“input”时更新

### 常用的内容渲染指令有哪些？其作用分别是什么？
（1）v-text指令：v-text指令会覆盖元素内默认的值。
（2）v-html指令：v-text指令和插值表达式只能渲染纯文本内容，如果要把包含HTML标签的字符串渲染为页面的HTML元素，则需要用到v-html这个指令。
（3）v-once指令：只渲染元素和组件一次，随后的渲染使用了此指令的元素/组件及其所有的子节点，都会当作静态内容并跳过，这可用于优化更新性能，v-once指令也不需要表达式。

### 在Vue.js中提供的props验证方式有哪些？其作用分别是什么？
（1）基础类型检测：允许参数为指定的一种类型。
（2）多种类型：参数允许为多种类型。
（3）必填项的校验：父组件向子组件传递props数据时，有可能传递的数据为空，但是在子组件中要求该数据是必须传递的。此时，可以在声明props时通过required属性设置必填项，强调组件的使用者必须传递属性的值。
（4）属性默认值：在声明props时，可以通过default属性定义属性默认值，当父组件没有向子组件的属性传递数据时，属性将会使用默认值。
（5）自定义验证函数：如果需要对从父组件中传入的数据进行验证，可以通过validator()函数来实现。

###  简单阐述一下单页面应用程序优点和缺点有哪些？
1、单页面应用程序优点：
（1）良好的交互体验
	①单页应用的内容的改变不需要重新加载整个页面
	②获取数据也是通过Ajax异步获取
	③没有页面之间的跳转，不会出现“白屏现象”
（2）良好的前后端工作分离模式
	①后端专注于提供 API 接口，更易实现 API 接口的复用
	②前端专注于页面的渲染，更利于前端工程化的发展
（3）减轻服务器的压力
	①服务器只提供数据，不负责页面的合成与逻辑的处理，吞吐能力会提高几倍

2、单页面应用程序缺点：
（1）首屏加载慢
	①路由懒加载
	②代码压缩
	③CDN 加速
	④网络传输压缩
（2）不利于 SEO
	①SSR 服务器端渲染

### 请简述Vue3.x中transition组件的6个内置的过渡类名。
（1）v-enter-from：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除
（2）v-enter-active：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型
（3）v-enter-to：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是 v-enter-from 被移除的同时)，在过渡或动画完成之后移除
（4）v-leave-from：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除
（5）v-leave-active：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。
（6）v-leave-to：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是 v-leave-from 被移除的同时)，在过渡或动画完成之后移除

### 在vue.js中插槽主要分为几类？其作用分别是什么？
在vue.js中插槽主要分为4类，其作用分别是：
（1）匿名插槽：当子组件模板只有一个没有属性（只有开始标签和结束标签）的插槽时，父组件整个内容片段将插入插槽所在的DOM位置，并替换掉<slot></slot>标签本身；
（2）提供默认内容的插槽：封装组件时，可以为预留的插槽提供默认内容（后备内容），如果组件的使用者没有为插槽提供任何内容，则默认内容会生效
（3）具名插槽：`<slot>`元素有一个特殊的属性name，这个属性可以用来定义多个插槽，可以为每个`<slot>`元素指定不同的name，这种带有具体名称的插槽叫作具名插槽
（4）作用域插槽：是一种特殊类型的插槽，它使用一个（能够传递数据的）可重用模板替换已渲染元素。在封装组件的过程中，可以为预留的插槽绑定props数据，这种带有props数据的插槽叫作作用域插槽。

### 简述如何使用Pinia实现数据持久化局部存储
在项目开发中，可以通过持久化插件pinia-plugin-persist实现持久化局部存储。
（1）首先需要安装Pinia和pinia-plugin-persist插件。
（2）在应用程序入口文件中，创建并导出Pinia实例。
（3）创建存储模块，在存储模块中定义需要进行持久化的状态和操作。
（4）使用存储模块。
（5）运行应用程序，在应用程序中使用存储模块的数据将会自动进行持久化存储。

### 简单阐述一下Pinia的优点有哪些？
（1）Pinia支持Vue 2和Vue 3，支持选项式API和组合式API写法。
（2）Pinia简化了状态管理库的使用方法，抛弃了mutations，只有state、getters和actions，让代码编写更容易也更直观。
（3）Pinia不需要嵌套模板，符合Vue 3中的组合式API，让代码更加扁平化
（4）Pinia提供了完整的TypeScript支持。
（5）Pinia分模块不需要借助modules，使代码更加简洁，可以实现良好的代码自动分隔。
（6）Pinia支持Devtools调试工具，便于进行调试。
（7）Pinia体积更小，性能更好。
（8）Pinia支持在某个组件中直接修改Pinia的state中的数据。
（9）Pinia支持服务端器渲染。

###  简单阐述一下Axios的特点有哪些？
（1）支持所有的 API。
（2）支持拦截请求和响应。
（3）可以转换请求数据和响应数据，并可以将响应的内容自动转换为JSON类型的数据。
（4）安全性高，客户端支持防御跨站请求伪造（Cross-Site Request Forgery，CSRF）。