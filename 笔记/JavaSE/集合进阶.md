## 集合体系结构
![[Pasted image 20251018101118.png]]
![[Pasted image 20251018101143.png]]
![[Pasted image 20251018101212.png]]
	有序：指的是存的顺序和取的顺序是一样的
![[Pasted image 20251018101318.png]]
## [[Collection]]
## List集合的特点
![[Pasted image 20251018141858.png]]
![[Pasted image 20251018141924.png]]
```Java
	//void add(int index,E element)
	//细节:原来索引上的元素会依次往后移，在此集合中的指定位置插入指定的元素
```
## List的遍历方式
![[Pasted image 20251018165820.png]]
![[Pasted image 20251018170441.png]]
## Set系列集合
![[Pasted image 20251020203834.png]]
![[Pasted image 20251020203844.png]]
![[Pasted image 20251020204744.png]]
### HashSet
![[Pasted image 20251020204830.png]]
![[Pasted image 20251020204848.png]]
![[Pasted image 20251020204918.png]]
![[Pasted image 20251020204946.png]]
![[Pasted image 20251020205115.png]]
### JDK8以前
![[Pasted image 20251021083322.png]]
#### 加载因子
![[Pasted image 20251021083715.png]]
![[Pasted image 20251021084601.png]]
## LinkHashSet
![[Pasted image 20251021085407.png]]
![[Pasted image 20251021085940.png]]
## TreeSet
![[Pasted image 20251021195210.png]]
![[Pasted image 20251021195732.png]]
### 指定排序方式
![[Pasted image 20251021201913.png]]
#### 方式一：
	使用默认的排序规则/自然排序
	Student实现Comparable接口，重写里面的抽象方法，再指定比较规则
```java
	public class Student implements Comparable<Student>{
		@Override
		public int compareTo(Student o){
			return this.getAge() - o.getAge();
		}
	}
```
![[Pasted image 20251021201049.png]]
> [!NOTE] this 和 o
	this：指代调用方法的对象本身，也就是点.前面的那个。可以理解为“我”。
    o：指代通过参数传递进来的对象，也就是括号()里面的那个。可以理解为“对方”。
#### 方式二：
	比较器排序
	实现Comparator接口
```Java
	TreeSet<String> ts = new TreeSet<>(new Comparator<String>() {  
	    @Override  
	    public int compare(String o1, String o2) {  
	        //根据长度比较  
	        int i = o1.length() - o2.length();  
	        //如果长度相同，再根据字母顺序比较  
	        i = i == 0 ? o1.compareTo(o2) : i;  
	        return i;  
	    }  
	});
```

> [!NOTE] o1和o2
![[Pasted image 20251023104515.png]]

![[Pasted image 20251021204404.png]]
## 总结
![[Pasted image 20251021204453.png]]
## 创建不可变的集合

> [!NOTE]
> 	不可被修改的集合
![[Pasted image 20251024115004.png]]
	格式
![[Pasted image 20251024115254.png]]
	细节：
>	当我们要获取一个不可变的Set集合时，里面的参数一定要保证唯一性
	创建Map的不可变集合
>细节一：
>	键是不能重复的
>细节二：
>	Map里面的of方法，参数是有上限的，最多只能传递20个参数，10个键值对
细节三：
创建Map的不可变集合，键值对的数量超过十个，可以使用ofEntries方法

## Map.Entry<String, String>

> [!NOTE]
> 表示键值对的类型
```Java
HashMap<String,String> hm = new HashMap<>();  
hm.put("1001","zhangsan");  
hm.put("1002","lisi");  
hm.put("1003","wangwu");  
hm.put("1004","zhaoliu");  
hm.put("1005","zhangsan");  
hm.put("1006","lisi");  
hm.put("1007","wangwu");  
hm.put("1008","zhaoliu");  
hm.put("1009","zhangsan");  
hm.put("1010","lisi");  
hm.put("1011","wangwu");  
hm.put("1012","zhaoliu");  
//获取到所有的键值对对象（Entry对象）  
Set<Map.Entry<String, String>> entries = hm.entrySet();  
//将entries转换为数组  
Map.Entry[] arr = new Map.Entry[0];  
/*toArray方法在底层会比较集合的长度跟数组的长度两者的大小  
如果集合的长度 > 数组的长度 : 数据在数组中放不下，此时会根据实际数据的个数，重新创建数组  
如果集合的长度<=数组的长度:数据在数组中放的下，此时不会创建新的数组，而是直接用*/  
Map.Entry[] array = entries.toArray(arr);  
//不可变的Map集合  
Map map = Map.ofEntries(array);  
System.out.println(map);

//可以用下面这种方式简写
Map<Object, Object> map = Map.ofEntries(hm.entrySet().toArray(new Map.Entry[0]));
//JDK10 以后
Map<String, String> map1 = Map.copyOf(hm);
```
