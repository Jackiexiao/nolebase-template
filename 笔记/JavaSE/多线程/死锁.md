---

share: 'true'
date modified: 2025年-12月-01日 19:19
created: 2025年-11月-29日 16:19
---

在Java多线程编程中，**死锁 (Deadlock)** 是最让人头疼的问题之一。它不是报错（Exception），而是程序突然“卡死”不动了，CPU占用率可能很低，但任务就是不往下走。

简单来说：**死锁就是两个（或多个）线程互相持有对方想要的锁，却谁都不肯先放手，导致大家都无法继续运行。**

以下是关于死锁的通俗解释、代码复现以及解决方案。

---

### 1. 生活中的“死锁”例子

想象两个人（线程）在吃西餐，但餐具只有 **一把刀** 和 **一把叉**（资源）。

- **A手里拿着刀**，想要叉子才能开吃。
- **B手里拿着叉**，想要刀子才能开吃。
- **死锁状态：** A等着B放下叉，B等着A放下刀。如果没人愿意先放下手里的东西，这顿饭永远吃不成。

### 3. 为什么会发生死锁？（四个必要条件）

死锁的发生必须同时满足以下4个条件（称为棺材钉）：

1. **互斥 (Mutual Exclusion)：** 资源是独占的（锁A同一时间只能被一个人拿）。
2. **请求与保持 (Hold and Wait)：** 吃着碗里的，看着锅里的（我拿着锁A不放，同时去请求锁B）。
3. **不剥夺 (No Preemption)：** 不能强抢（除非我主动释放，否则你不能把锁A从我手里抢走）。
4. **循环等待 (Circular Wait)：** 形成了一个闭环（A等B，B等A）。

**只要打破其中任何一个条件，死锁就解开了。**
