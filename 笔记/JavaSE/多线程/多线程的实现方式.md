---
share: "true"
created: 星期二, 十一月 25日 2025, 8:25:27 晚上
date modified: 星期六, 十一月 29日 2025, 6:36:56 晚上
---

![](../../img/Pasted%20image%2020251125202556.png)

## 第一种实现方式

```Java
public class MyThread01 extends Thread{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(getName() + "hello");
        }
    }
}

//测试类
public class MultiDemo {
    public static void main(String[] args) {
        /*
         *多线程的第一种实现方式
         * 1、定义一个类继承Thread
         * 2、重写run方法
         * 3、创建子类对象，并启动线程
         * */
        MyThread01 t1 = new MyThread01();
        MyThread01 t2 = new MyThread01();
        t1.setName("线程1");
        t2.setName("线程2");
        //启动线程
        t2.start();
        t1.start();
    }
}
```

## 第二种实现方式

```Java
public class MyRun implements Runnable{
    @Override
    public void run() {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + "hello");
        }
    }
}
//测试类代码
public class MultiDemo02 {
    public static void main(String[] args) {
        /*
         * 多线程的第二种实现方式
         * 1、定义一个类实现Runnable接口
         * 2、重写run方法
         * 3、创建自己的类的对象
         * 4、创建一个Thread类的对象，并开启多线程
         * */
        //创建MyRun对象
        //表示多线程要执行的任务
        MyRun myRun = new MyRun();
        //创建线程对象
        Thread t1 = new Thread(myRun);
        Thread t2 = new Thread(myRun);
        //设置线程名称
        t2.setName("线程2");
        t1.setName("线程1");

        //开启线程
        t1.start();
        t2.start();
    }
}
```

## 第三种实现方式

```Java
//泛型表示返回值的类型
public class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 1; i < 101; i++) {
            sum += i;
        }
        return sum;
    }
}

//测试类
public class MultiDemo03 {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        /*
        * 多线程的第三种实现方式
        * 特点：
        *   可以获取到多线程运行的结果
        * 1、创建一个MyCallable类实现Callable接口
        * 2、重写call方法（是有返回值的，表示多线程运行的结果）
        * 3、创建MyCallable对象（作用管理多线程运行的结果）
        * 4、创建一个FutureTask类（Future的实现对象）的对象，管理多线程运行的结果
        * 5、创建一个Thread类的对象，并开启多线程
        * */
        MyCallable myCall = new MyCallable();
        FutureTask<Integer> futureTask = new FutureTask<>(myCall);
        Thread t1 = new Thread(futureTask);
        //开启线程
        t1.start();

        //获取多线程的结果(通过get()方法)
        System.out.println(futureTask.get());
    }
}
```
## 三种实现方式的对比
![](../../img/Pasted%20image%2020251125205526.png)
