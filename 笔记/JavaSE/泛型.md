---
share: "true"
---
![Pasted image 20251020133300](../img/Pasted%20image%2020251020133300.png)
	如果我们没有给集合指定类型，默认认为所有的数据类型都是object类型
	此时可以往集合添加任意的数据类型。
	带来一个坏处:我们在获取数据的时候，无法使用他的特有行为。
	此时推出了泛型，可以在添加数据的时候就把类型进行统一。
	而且我们在获取数据的时候，也省的强转了，非常的方便。
![Pasted image 20251020133754](../img/Pasted%20image%2020251020133754.png)
## 泛型的细节
![Pasted image 20251020133909](../img/Pasted%20image%2020251020133909.png)
## 泛型类
![Pasted image 20251020134010](../img/Pasted%20image%2020251020134010.png)
![Pasted image 20251020134033](../img/Pasted%20image%2020251020134033.png)
## 泛型方法
![Pasted image 20251020135812](../img/Pasted%20image%2020251020135812.png)
![Pasted image 20251020135837](../img/Pasted%20image%2020251020135837.png)
## 泛型接口
![Pasted image 20251020141025](../img/Pasted%20image%2020251020141025.png)
![Pasted image 20251020141054](../img/Pasted%20image%2020251020141054.png)
## 泛型的继承
![Pasted image 20251020154908](../img/Pasted%20image%2020251020154908.png)
## 泛型通配符
	此时我们就可以使用泛型的通配符:
		?也表示不确定的类型
		他可以进行类型的限定
		?extendsE:表示可以传递E或者E所有的子类类型
		?super E:表示可以传递E或者E所有的父类类型
	应用场景:
		1.如果我们在定义类、方法、接口的时候，如果类型不确定，就可以定义泛型类、泛型方法、泛型接口。
		2.如果类型不确定，但是能知道以后只能传递某个继承体系中的，就可以泛型的通配符
	泛型的通配符:
		关键点:可以限定类型的范围。

![Pasted image 20251020173327](../img/Pasted%20image%2020251020173327.png)
![Pasted image 20251020173424](../img/Pasted%20image%2020251020173424.png)
